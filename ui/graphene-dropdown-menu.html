<!--
Copyright (c) 2018, Cyber Dyne SRL. All rights reserved.
This code may only be used under the BSD style license found at https://github.com/cyber-dyne/graphene/License.txt
The complete set of authors may be found at https://github.com/cyber-dyne/graphene/Authors.txt
The complete set of contributors may be found at https://github.com/cyber-dyne/graphene/Contributors.txt
-->
<link rel="import" href="../../iron-list/iron-list.html"/>
<link rel="import" href="../../paper-dropdown-menu/paper-dropdown-menu.html"/>
<link rel="import" href="../../paper-input/paper-input.html"/>
<link rel="import" href="../../polymer/polymer.html"/>
<link rel="import" href="../core/graphene-localize-behavior.html"/>
<link rel="import" href="../lib/lodash.html"/>
<link rel="import" href="graphene-dropdown-menu-behavior.html"/>
<link rel="import" href="graphene-icons.html"/>
<link rel="import" href="graphene-style.html"/>

<dom-module id="graphene-dropdown-menu">
    <template>
        <style include="graphene-style"></style>

        <style>
            host {
                display: block;
            }

            paper-dropdown-menu {
                width: 100%;
                --paper-input-container-underline: {
                    border-bottom: 1px solid var(--paper-grey-200);
                };
                --paper-dropdown-menu-button: {
                    /*
                    * Fixes the
                    * <span role="button"></span>
                    * pushing down the <paper-menu-button> in Shady DOM.
                    */
                    float: left;
                    width: 100%;
                };
            }

            #Content {
                background-color: var(--graphene-dropdown-menu-background-color);
            }

            #Filter {
                /* <paper-input> */
                width: var(--graphene-dropdown-menu-width, 400px);
                padding: var(--graphene-gutter-xs) var(--graphene-gutter-s);
                background-color: var(--graphene-dropdown-menu-background-color);

                --paper-input-container-input: {
                    padding: 5px 0;
                };
                --paper-input-container-underline: {
                    border-bottom: 1px solid var(--paper-grey-200);
                };
                --paper-input-container-focus-color: var(--graphene-dropdown-menu-focus-color);
            }

            #Filter iron-icon[prefix] {
                --iron-icon: {
                    margin-right: var(--graphene-gutter-xs);
                    color:        var(--paper-grey-500);
                };
            }

            #EmptyItem,
            #List > * {
                padding: 0 var(--graphene-gutter-s);

                line-height:    2.2em;
                letter-spacing: -0.02em;
                font-weight:    400;

                vertical-align: middle;
                overflow:       hidden;
                text-overflow:  ellipsis;
            }

            #List > * {
                display: inline-block;  /* For vertical-align. */
            }

            #EmptyItem {
                cursor: pointer;
                font-size: 0.9em;
                color:            var(--graphene-dropdown-menu-color);
                background-color: var(--graphene-dropdown-menu-background-color);

                user-select: none;
                -webkit-user-select: none;
            }

            #List {
                /* <iron-list> */
                width:  var(--graphene-dropdown-menu-width,  400px);
                height: var(--graphene-dropdown-menu-height, 400px);

                cursor: pointer;

                --iron-list-items-container: {
                    font-size: 0.9em;

                    color:            var(--graphene-dropdown-menu-color);
                    background-color: var(--graphene-dropdown-menu-background-color);
                };
            }

            #EmptyItem:hover,
            #List > *:hover {
                background-color: var(--graphene-dropdown-menu-focus-color);
            }

            #List > *[selected] {
                color:            var(--graphene-dropdown-menu-selected-item-color);
                background-color: var(--graphene-dropdown-menu-selected-item-background-color);
            }

            #List > *:focus {
                outline: none;
                background-color: var(--graphene-dropdown-menu-focus-color);
            }
        </style>

        <paper-dropdown-menu id="Menu"
                             label="[[ label ]]"
                             vertical-align="[[ valign ]]"
                             horizontal-align="[[ halign ]]"
                             disabled="[[ disabled ]]"
                             required="[[ required ]]"
                             invalid="{{ invalid }}"
                             on-selected-item-changed="_stopEvent">

            <div id="Content" class="dropdown-content">
                <paper-input id="Filter"
                             type="search"
                             no-label-float
                             hidden$="[[ ! filter ]]"
                             on-value-changed="_searchValueChanged">
                    <iron-icon icon="icons:search" prefix></iron-icon>
                </paper-input>

                <slot id="HeaderSlot" name="header"></slot>

                <div id="EmptyItem"
                     on-tap="_onEmptyItemTap"
                     hidden$="[[ ! _emptyItemIsEnabled(emptyItem, deselectable, multi) ]]">
                    &nbsp;
                </div>

                <!--
                | iron-list doesn't support selecting an item through the binding
                | but requires an imperative call of the method .selectItem().
                -->
                <iron-list id="List"
                           items="[[ filteredItems ]]">
                    <template>
                        <div tabindex$="[[ _tabIndex(item, index) ]]"
                             selected$="[[ _selected(selectedItems, item, index, multi) ]]"
                             on-tap="_onItemTap">
                            [[ itemTitleFormatter(item, index, itemTitlePath) ]]
                        </div>
                    </template>
                </iron-list>

                <slot id="FooterSlot" name="footer"></slot>
            </div>

        </paper-dropdown-menu>
    </template>

    <script>
        // <![CDATA[
        ;(function (undefined) {
            'use strict'

            Polymer({
                is: 'graphene-dropdown-menu',

                behaviors: [
                    Graphene.DropdownMenuBehavior,
                    Graphene.LocalizeBehavior,
                ],

                properties: {
                    label: {
                        type: String,
                    },

                    titleFormatter: {
                        type: Function,
                        computed: '_titleFormatterComputer(titleFormatterFn, itemTitleFormatter)',
                    },

                    titleFormatterFn: {
                        type: Function,
                        value() {
                            return function titleFormatter(selected, itemTitleFormatter) {
                                if (! selected) {
                                    return
                                }

                                const selectedItems = Array.isArray(selected)
                                    ? selected
                                    : [ selected ]
                                const title = selectedItems.map(itemTitleFormatter).join(', ')

                                return title
                            }
                        },
                    },

                    disabled: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    required: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    invalid: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true,
                    },

                    items: {
                        type: Array,
                    },

                    filteredItems: {
                        type: Array,
                        computed: '_filteredItemsComputer(items, search)',
                    },

                    itemTitlePath: {
                        type: String,
                        value: 'name',
                    },

                    itemTitleFormatter: {
                        type: Function,
                        computed: '_itemTitleFormatterComputer(itemTitleFormatterFn, itemTitlePath)',
                    },

                    itemTitleFormatterFn: {
                        type: Function,
                        value() {
                            return function itemTitleFormatter(item, index, path) {
                                return Lodash.get(item, path)
                            }
                        },
                    },

                    selectedItems: {
                        type: Object,
                        notify: true,
                    },

                    multi: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    emptyItem: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    deselectable: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    autoSelect: {
                        type: Boolean,
                        value: false,
                    },

                    autoReset: {
                        type: Boolean,
                        value: false,
                    },

                    filter: {
                        type: Boolean,
                        value: false,
                    },

                    filterFields: {
                        type: Array,
                        value() {
                            return [ 'name' ]
                        },
                    },

                    search: {
                        type: String,
                        value: '',
                    },

                    maxHeight: {
                        type: Number,
                    },

                    itemHeight: {
                        type: Number,
                    },

                    valign: {
                        type: String,
                        value: 'top',
                    },

                    halign: {
                        type: String,
                        value: 'left',
                    },
                },

                observers: [
                    '_setItemsSize(items, itemHeight, maxHeight)',
                    '_selectAuto(items, multi, autoSelect)',
                    '_resetAuto(items, autoReset, autoSelect, multi)',
                    '_setTitle(selectedItems, titleFormatter)',
                ],

                listeners: {
                    'Menu.opened-changed': '_menuOpenedChangedListener',
                },

                //// Lifecycle callbacks. //////////////////////////////////////

                //// Computers. ////////////////////////////////////////////////

                _titleFormatterComputer(titleFormatterFn, itemTitleFormatter, itemTitlePath) {
                    return function titleFormatterWrapper(selected) {
                        return titleFormatterFn(selected, itemTitleFormatter, itemTitlePath)
                    }
                },

                _itemTitleFormatterComputer(itemTitleFormatterFn, itemTitlePath) {
                    return function itemTitleFormatterWrapper(item, index) {
                        return itemTitleFormatterFn(item, index, itemTitlePath)
                    }
                },

                _filteredItemsComputer(items, search) {
                    const query = search.trim().toLowerCase()

                    const filteredItems = query
                        ? items.filter(it => this._doesMatch(it, query))
                        : items // Optimization.

                    return filteredItems
                },

                //// Observers. ////////////////////////////////////////////////

                _setItemsSize(items, itemHeight, maxHeight) {
                    if (Lodash.some(arguments, Lodash.isNil)) {
                        return
                    }

                    if (itemHeight === 0) {
                        return
                    }

                    const itemsSize   = items.length
                    const itemsHeight = itemHeight * itemsSize
                    const height      = Math.min(itemsHeight, maxHeight)
                    // const width       = Math.min(itemWidth,   maxWidth)
                    const list        = this.$.List

                    list.style.height = height + 'px'
                },

                _selectAuto(items, multi, autoSelect) {
                    if (Lodash.some(arguments, Lodash.isNil)) {
                        return
                    }

                    if (autoSelect !== true) {
                        return
                    }

                    if (items.length !== 1) {
                        return
                    }

                    const autoSelected = items[0]

                    const isMultiSelected = multi
                        && this.selectedItems
                        && this.selectedItems[0] === autoSelected

                    if (isMultiSelected) {
                        // Auto selection candidate is already selected. We
                        // must stop otherwise we would tigger a change event
                        // with the same selected item but in a new array,
                        // breaking the Polymer dirty checking.
                        // This is only true for multi selection because in
                        // single selection assigning an object to a property
                        // with the same object does not trigger a change.
                        return
                    }

                    this.selectedItems = multi
                        ? [ autoSelected ]
                        : autoSelected
                },

                _resetAuto(items, autoReset, autoSelect, multi) {
                    // This method must not observe selectedItems, but only
                    // acting when the items change.
                    if (Lodash.some(arguments, Lodash.isNil)) {
                        return
                    }

                    if (autoReset !== true) {
                        return
                    }

                    if (autoSelect && items.length === 1) {
                        // We must not conflitct with the auto select.
                        return
                    }

                    if (! this.selectedItems) {
                        // Nothing to reset.
                        return
                    }

                    if (multi && this.selectedItems.length === 0) {
                        // Nothing to reset.
                        return
                    }

                    if (multi) {
                        const availableItems = this.selectedItems.filter(it =>
                            items.includes(it)
                        )

                        if (availableItems.length === this.selectedItems.length) {
                            // All selected items are available in the items list.
                            // We have nothing to reset.
                            return
                        }

                        if (availableItems.length > 0) {
                            // Some selected items are available in the items list.
                            // We fix the selected items.
                            this.selectedItems = availableItems

                            return
                        }
                    }

                    this.selectedItems = null
                },

                _setTitle(selectedItemsChange, titleFormatter) {
                    // Don't do this because selectedItemsChange is null when
                    // multi is false and the user deselects the item.
                    // if (Lodash.some(arguments, Lodash.isNil)) {
                    //     return
                    // }

                    const selectedItems = this.selectedItems
                    const title = titleFormatter(selectedItems)
                    const target = this.$.Content

                    if (! title) {
                        this.fire('iron-deselect', undefined, { node: target })

                        return
                    }

                    const itemNode = this.create('span', { label: title })

                    this.fire('iron-select', { item: itemNode }, { node: target })
                },

                //// Listeners. ////////////////////////////////////////////////

                _menuOpenedChangedListener(event, detail) {
                    const node            = Polymer.dom(event).rootTarget    // Who fired the event.
                    const isPaperDropdown = node.localName === 'paper-dropdown-menu'

                    if (! isPaperDropdown) {
                        return
                    }

                    const dropdownMenu = this.$.Menu
                    const menuButton   = dropdownMenu.$$('paper-menu-button')
                    const dropdown     = menuButton.$$('iron-dropdown')

                    // iron-list are rendered only when visible, but the
                    // iron-dropdown imposes display:none on the content (the
                    // iron-list) resulting in an iron-list not rendered until
                    // the iron-dropdown becomes visible, but at this point the
                    // iron-dropdown has already computed its content
                    // (iron-list) size which is zero.  We give a bit of time
                    // to the iron-dropdown to display the iron-list and to the
                    // iron-list to generate its content and, after that, we
                    // inform the paper-dropdown-menu to recompute its content
                    // size.
                    this.async(() => dropdown.notifyResize, 400)

                    const isOpenChange = detail.value
                    const hasFilter    = this.filter !== undefined

                    if (! isOpenChange || ! hasFilter) {
                        return
                    }

                    const input = this.$.Filter.inputElement

                    // We want to focus the filter input, with a delay due to the
                    // dropdown content opening animation
                    this.async(() => input.focus(), 400)
                },

                _stopEvent(event) {
                    // Internal events must not escaped from the component.
                    event.stopPropagation()
                },

                _onItemTap(event) {
                    const target = Polymer.dom(event).localTarget
                    const list = this.$.List
                    const model = list.modelForElement(target)
                    const as = list.as
                    const indexAs = list.indexAs
                    const item = model[as]
                    const index = model[indexAs]
                    const alreadySelected = this._selected(this.selectedItems, item, index, this.multi)

                    if (this.multi) {
                        const dropdownMenu = this.$.Menu
                        const menuButton = dropdownMenu.$$('paper-menu-button')
                        const selectedItems = this.selectedItems || []

                        // We prevent the dropdown from closing during a multi selection.
                        this.configurePaperMenuButton(menuButton, false)

                        this.selectedItems = alreadySelected
                            ? selectedItems.filter(it => it !== item)
                            : selectedItems.concat([ item ])

                        // We restore the normal behavior, in case the selection
                        // mode changes.
                        this.configurePaperMenuButton(menuButton, true)
                    }
                    else {
                        this.selectedItems = alreadySelected
                            ? null
                            : item
                    }
                },

                // _preventDeselect(event) {
                //     const target = Polymer.dom(event).localTarget
                //
                //     if (this.multi) {
                //         return
                //     }
                //
                //     if (! target.hasAttribute('selected')) {
                //         return
                //     }
                //
                //     event.stopPropagation()
                // },

                _onEmptyItemTap(event) {
                    const menu = this.$.Menu

                    menu.close()

                    this.selectedItems = null
                },

                _searchValueChanged(event, detail) {
                    const value = detail.value
                    const debounceId = '_searchValueChanged'
                    const debounceTime = 300
                    const debounceFn = () => this.search = value

                    this.debounce(debounceId, debounceFn, debounceTime)
                },

                //// Public APIs. //////////////////////////////////////////////

                reset() {
                    this.selectedItems = null
                },

                validate() {
                    const menu = this.$.Menu
                    const valid = menu.validate()

                    return valid
                },

                //// Internal APIs. ////////////////////////////////////////////

                _emptyItemIsEnabled(emptyItem, deselectable, multi) {
                    return false
                    // return multi !== true && deselectable === true
                },

                _tabIndex(item, index) {
                    return 0
                },

                _selected(selectedItems, item, index, multi) {
                    if (! selectedItems) {
                        // Optimization.
                        return false
                    }

                    return multi
                        ? selectedItems.includes(item)
                        : selectedItems === item
                },

                _doesMatch(item, query) {
                    const fields = this.filterFields
                    const text = fields.reduce((text, field) =>
                         text + (item[field] || '').toLowerCase()
                    , '')
                    const doesMatch = text.includes(query)

                    return doesMatch
                },
            })
        })()
        // ]]>
    </script>
</dom-module>
