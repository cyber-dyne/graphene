<!--
Copyright (c) 2018, Cyber Dyne SRL. All rights reserved.
This code may only be used under the BSD style license found at https://github.com/cyber-dyne/graphene/License.txt
The complete set of authors may be found at https://github.com/cyber-dyne/graphene/Authors.txt
The complete set of contributors may be found at https://github.com/cyber-dyne/graphene/Contributors.txt
-->
<link rel="import" href="../../iron-list/iron-list.html"/>
<link rel="import" href="../../paper-dropdown-menu/paper-dropdown-menu.html"/>
<link rel="import" href="../../paper-input/paper-input.html"/>
<link rel="import" href="../../polymer/polymer.html"/>
<link rel="import" href="../core/graphene-localize-behavior.html"/>
<link rel="import" href="../lib/lodash.html"/>
<link rel="import" href="graphene-dropdown-menu-behavior.html"/>
<link rel="import" href="graphene-icons.html"/>
<link rel="import" href="graphene-style.html"/>

<dom-module id="graphene-dropdown-menu">
    <template>
        <style include="graphene-style"></style>

        <style>
            host {
                display: block;
            }

            paper-dropdown-menu {
                width: 100%;
                --paper-input-container-underline: {
                    border-bottom: 1px solid var(--paper-grey-200);
                };
                --paper-dropdown-menu-button: {
                    /*
                    * Fixes the
                    * <span role="button"></span>
                    * pushing down the <paper-menu-button> in Shady DOM.
                    */
                    float: left;
                    width: 100%;
                };
            }

            #Content {
                background-color: var(--graphene-dropdown-menu-background-color);
            }

            #Filter {
                /* <paper-input> */
                width: var(--graphene-dropdown-menu-width, 400px);
                padding: var(--graphene-gutter-xs) var(--graphene-gutter-s);
                background-color: var(--graphene-dropdown-menu-background-color);

                --paper-input-container-input: {
                    padding: 5px 0;
                };
                --paper-input-container-underline: {
                    border-bottom: 1px solid var(--paper-grey-200);
                };
                --paper-input-container-focus-color: var(--graphene-dropdown-menu-focus-color);
            }

            #Filter iron-icon[prefix] {
                --iron-icon: {
                    margin-right: var(--graphene-gutter-xs);
                    color:        var(--paper-grey-500);
                };
            }

            #EmptyItem,
            #List > * {
                padding: 0 var(--graphene-gutter-s);

                line-height:    2.2em;
                letter-spacing: -0.02em;
                font-weight:    400;

                vertical-align: middle;
                overflow:       hidden;
                text-overflow:  ellipsis;
            }

            #List > * {
                display: inline-block;  /* For vertical-align. */
            }

            #EmptyItem {
                cursor: pointer;
                font-size: 0.9em;
                color:            var(--graphene-dropdown-menu-color);
                background-color: var(--graphene-dropdown-menu-background-color);

                user-select: none;
                -webkit-user-select: none;
            }

            #List {
                /* <iron-list> */
                width:  var(--graphene-dropdown-menu-width,  400px);
                height: var(--graphene-dropdown-menu-height, 400px);

                cursor: pointer;

                --iron-list-items-container: {
                    font-size: 0.9em;

                    color:            var(--graphene-dropdown-menu-color);
                    background-color: var(--graphene-dropdown-menu-background-color);
                };
            }

            #EmptyItem:hover,
            #List > *:hover {
                background-color: var(--graphene-dropdown-menu-focus-color);
            }

            #List > *[selected] {
                color:            var(--graphene-dropdown-menu-selected-item-color);
                background-color: var(--graphene-dropdown-menu-selected-item-background-color);
            }

            #List > *:focus {
                outline: none;
                background-color: var(--graphene-dropdown-menu-focus-color);
            }
        </style>

        <paper-dropdown-menu id="Menu"
                             label="[[ label ]]"
                             vertical-align="[[ valign ]]"
                             horizontal-align="[[ halign ]]"
                             disabled="[[ disabled ]]"
                             required="[[ required ]]"
                             invalid="{{ invalid }}"
                             on-selected-item-changed="_stopEvent">

            <div id="Content" class="dropdown-content">
                <paper-input id="Filter"
                             type="search"
                             no-label-float
                             hidden$="[[ ! filter ]]"
                             on-value-changed="_searchValueChanged">
                    <iron-icon icon="icons:search" prefix></iron-icon>
                </paper-input>

                <slot id="HeaderSlot" name="header"></slot>

                <!--
                <div id="EmptyItem"
                     on-tap="_onDeselectTap"
                     hidden$="[[ ! _deselectIsEnabled(deselectable, multi) ]]">
                    &nbsp;
                </div>
                -->

                <!--
                | iron-list doesn't support selecting an item through the binding
                | but requires an imperative call of the method .selectItem().
                -->
                <iron-list id="List"
                           items="[[ filteredItems ]]"
                           selection-enabled
                           multi-selection="[[ multi ]]"
                           on-selected-item-changed="_stopEvent"
                           on-selected-items-changed="_selectedItemsChanged">
                    <template>
                        <div tabindex$="[[ tabIndex ]]"
                             selected$="[[ selected ]]"
                             off-on-tap="_preventDeselect">
                            [[ _itemText(item, itemField) ]]
                        </div>
                    </template>
                </iron-list>

                <slot id="FooterSlot" name="footer"></slot>
            </div>

        </paper-dropdown-menu>
    </template>

    <script>
        // <![CDATA[
        ;(function (undefined) {
            'use strict'

            Polymer({
                is: 'graphene-dropdown-menu',

                behaviors: [
                    Graphene.DropdownMenuBehavior,
                    Graphene.LocalizeBehavior,
                ],

                properties: {
                    items: {
                        type: Array,
                    },

                    itemAs: {
                        type: String,
                        value: 'item',
                    },

                    itemField: {
                        type: String,
                        value: 'name',
                    },

                    filteredItems: {
                        type: Array,
                        computed: '_filteredItemsComputer(items, search)',
                    },

                    selectedItems: {
                        type: Object,
                        notify: true,
                    },

                    disabled: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    required: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    invalid: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true,
                    },

                    label: {
                        type: String,
                    },

                    titleFormatter: {
                        type: Function,
                        value() {
                            function titleFormatter(selected) {
                                const title = Lodash.isArray(selected)
                                    ? selected.map(it => it.name).join(', ')
                                    : selected.name

                                return title
                            }

                            return titleFormatter
                        },
                    },

                    multi: {
                        type: Boolean,
                        value: false,
                        reflectToAttribute: true,
                    },

                    // deselectable: {
                    //     type: Boolean,
                    //     value: false,
                    //     reflectToAttribute: true,
                    // },

                    manualSelect: {
                        type: Boolean,
                        value: false,
                    },

                    filter: {
                        type: Boolean,
                        value: false,
                    },

                    filterFields: {
                        type: Array,
                        value() {
                            return [ 'name' ]
                        },
                    },

                    search: {
                        type: String,
                        value: '',
                    },

                    maxHeight: {
                        type: Number,
                    },

                    itemHeight: {
                        type: Number,
                    },

                    valign: {
                        type: String,
                        value: 'top',
                    },

                    halign: {
                        type: String,
                        value: 'left',
                    },
                },

                observers: [
                    '_setItemsSize(items, itemHeight, maxHeight)',

                    '_selectAuto(items, multi)',

                    '_select(filteredItems, selectedItems)',

                    '_setTitle(selectedItems, multi, titleFormatter)',
                    '_setTitle(selectedItems.length, multi, titleFormatter)',
                ],

                listeners: {
                    'Menu.opened-changed': '_menuOpenedChangedListener',
                },

                //// Lifecycle callbacks. //////////////////////////////////////

                //// Computers. ////////////////////////////////////////////////

                _filteredItemsComputer(items, search) {
                    // We have to skip the iron-list selection reset when
                    // items change. It results in a selected-items-changed
                    // with detail.value === null for single selection
                    // and detail.value === [] for multi selection.
                    this._downwardItems = true

                    const query = search.trim().toLowerCase()

                    // Optimization.
                    const filteredItems = query
                        ? items.filter(it => this._doesMatch(it, query))
                        : items

                    // Safe lock release.
                    this.async(() => this._downwardItems = false, 300)

                    return filteredItems
                },

                //// Observers. ////////////////////////////////////////////////

                _setItemsSize(items, itemHeight, maxHeight) {
                    if (Lodash.some(arguments, Lodash.isNil)) {
                        return
                    }

                    if (itemHeight === 0) {
                        return
                    }

                    const itemsSize   = items.length
                    const itemsHeight = itemHeight * itemsSize
                    const height      = Math.min(itemsHeight, maxHeight)
                    // const width       = Math.min(itemWidth,   maxWidth)
                    const list        = this.$.List

                    list.style.height = height + 'px'
                },

                _selectAuto(items, multi) {
                    if (Lodash.some(arguments, Lodash.isNil)) {
                        return
                    }

                    if (this.manualSelect === true) {
                        return
                    }

                    if (items.length !== 1) {
                        return
                    }

                    const selectedAuto = multi
                        ? items.slice(0, 1)
                        : items[0]

                    if (multi && Lodash.isEqual(selectedAuto, this.selectedItems)) {
                        return
                    }

                    this.selectedItems = selectedAuto
                },

                _select(items, selected) {
                    const list = this.$.List

                    if (! items) {
                        return
                    }

                    if (! list.items) {
                        // This should not happen.
                        return
                    }

                    if (this.multi) {
                        // We are handling a multi selection.

                        // 1) We begin a downward propagation.
                        this._downwardSelection = true

                        const selectedItems = selected || [] // 'selected' could be null or undefined.

                        // 2)
                        // We deselect on the iron-list every item not selected
                        // in the graphene-dropdown-menu.
                        list.items.forEach(it => {
                            if (! selectedItems.includes(it)) {
                                // The iron-list item is not in the list of the
                                // selected items. We must deselect it.
                                list.deselectItem(it)
                            }
                        })
                        // 3)
                        // We select on the iron-list every item selected in
                        // the graphene-dropdown-menu.
                        selectedItems.forEach(it => {
                            if (! list.items.includes(it)) {
                                // It's ok, maybe because the user is filtering.
                                console.debug(this.localName, 'has not the item:', it, 'in', list.items, this)

                                return
                            }

                            list.selectItem(it)
                        })

                        // 4) We end the downward propagation.
                        this._downwardSelection = false

                        return
                    }

                    if (Lodash.isNil(selected)) {
                        // We are handing a single selection dropdown and we
                        // have to deselect the item of the iron-list.
                        this._downwardSelection = true
                        list.clearSelection()
                        this._downwardSelection = false

                        return
                    }

                    if (! list.items.includes(selected)) {
                        // It's ok, maybe because the user is filtering.
                        console.debug(this.localName, 'has not the item:', selected, 'in', list.items, this)

                        return
                    }

                    // We are handling a single selection dropdown and we have
                    // to select on the iron-list the selected item of the
                    // graphene-dropdown-menu.
                    this._downwardSelection = true
                    list.selectItem(selected)
                    this._downwardSelection = false
                },

                _setTitle(selectedItemsChange, multi, titleFormatter) {
                    // Don't do this because selectedItemsChange is null when
                    // multi is false and the user deselects the item.
                    // if (Lodash.some(arguments, Lodash.isNil)) {
                    //     return
                    // }

                    const selectedItems = this.selectedItems
                    const title = titleFormatter(selectedItems || { name: '' })
                    const target = this.$.Content

                    if (title) {
                        const itemNode = this.create('span', { label: title })

                        this.fire('iron-select', { item: itemNode }, { node: target })
                    }
                    else {
                        this.fire('iron-deselect', undefined, { node: target })
                    }

                    return this
                },

                //// Listeners. ////////////////////////////////////////////////

                _menuOpenedChangedListener(event, detail) {
                    const node            = Polymer.dom(event).rootTarget    // Who fired the event.
                    const isPaperDropdown = node.localName === 'paper-dropdown-menu'

                    if (! isPaperDropdown) {
                        return
                    }

                    const dropdownMenu = this.$.Menu
                    const menuButton   = dropdownMenu.$$('paper-menu-button')
                    const dropdown     = menuButton.$$('iron-dropdown')

                    // iron-list are rendered only when visible, but the
                    // iron-dropdown imposes display:none on the content (the
                    // iron-list) resulting in an iron-list not rendered until
                    // the iron-dropdown becomes visible, but at this point the
                    // iron-dropdown has already computed its content
                    // (iron-list) size which is zero.  We give a bit of time
                    // to the iron-dropdown to display the iron-list and to the
                    // iron-list to generate its content and, after that, we
                    // inform the paper-dropdown-menu to recompute its content
                    // size.
                    this.async(() => dropdown.notifyResize, 400)

                    const isOpenChange = detail.value
                    const hasFilter    = this.filter !== undefined

                    if (! isOpenChange || ! hasFilter) {
                        return
                    }

                    function focusFilter() {
                        const input = this.$.Filter.inputElement
                        input.focus()
                    }

                    // We want to focus the filter input, with a delay due to the
                    // dropdown content opening animation
                    this.async(focusFilter.bind(this), 400)
                },

                _stopEvent(event) {
                    // Internal events must not escaped from the component.
                    event.stopPropagation()
                },

                _selectedItemsChanged(event, detail) {
                    this._stopEvent(event)

                    if (this._downwardSelection) {
                        // Downward selection in progress.
                        return
                    }

                    const source = Polymer.dom(event).rootTarget
                    const target = Polymer.dom(event).localTarget

                    if (source !== target) {
                        // Event can be fired by an internal component
                        // (ex. paper-dropdown-menu, iron-list and array-selector).
                        return
                    }

                    if (this._downwardItems === true) {
                        // We have to skip the iron-list selection reset when
                        // items change.
                        this._downwardItems = false

                        return
                    }

                    // This function can be executed for 5 reasons.
                    // When multi selection is true, for a
                    // - '.splices' notification (detail.path includes '.splices')
                    // - '.length' notification (detail.path includes '.length')
                    // - <iron-list>.clearSelection() (detail.value === [])
                    // When multi selection is false, for
                    // - deselect (detail.value === null)
                    // - select (detail.value is the item)

                    const isLengthChange = detail.path && detail.path.includes('.length')
                    // const isSpliceChange = detail.path && detail.path.includes('.splices')

                    if (isLengthChange) {
                        // The '.length' change notification arrives right after
                        // we '.splices' notification. We skip it because we
                        // we don't need to re-debounce the set.
                        return
                    }

                    // We can't use this.multi because it can be undefined,
                    // when the iron-list fires the event before we are ready.
                    // It happens and bad things follows to it.
                    const isMulti = target.multiSelection

                    // if (isMulti) {
                    //     const oldItems = this.selectedItems
                    //     const newItems = target.selectedItems
                    //
                    //     // iron-list fires a change event after we propagate
                    //     // downward the changes.  Due to the selectedItems.slice(),
                    //     // selectedItems is always a new array and we can't
                    //     // simply assign it to this.selectedItems because it
                    //     // would trigger a change and an other iron-list event
                    //     // resulting in an infinite loop. We must stop it.
                    //     if (Lodash.isEqual(oldItems, newItems)) {
                    //         // Nothing actually changed. We can skip it.
                    //         return
                    //     }
                    // }

                    const value = isMulti
                        // We shallow clone the array because Polymer mutates in place.
                        ? target.selectedItems.slice()
                        // target.selectedItem has the old value (not yet updated).
                        // detail.value has the updated value.
                        : detail.value

                    const debounceTime = 100
                    const debounceId = '_selectedItemsChanged'
                    const debounceFn = () => this.selectedItems = value

                    this.debounce(debounceId, debounceFn, debounceTime)
                },

                // _preventDeselect(event) {
                //     const target = Polymer.dom(event).localTarget
                //
                //     if (this.multi) {
                //         return
                //     }
                //
                //     if (! target.hasAttribute('selected')) {
                //         return
                //     }
                //
                //     event.stopPropagation()
                // },

                // _onDeselectTap(event) {
                //     const menu = this.$.Menu
                //
                //
                //     menu.close()
                //
                //     this.selectedItems = null
                // },

                _searchValueChanged(event, detail) {
                    const value = detail.value
                    const debounceId = '_searchValueChanged'
                    const debounceTime = 300
                    const debounceFn = () => {
                        // We have to skip the iron-list selection reset when
                        // items change. It results in a selected-items-changed
                        // with detail.value === null for single selection
                        // and detail.value === [] for multi selection.
                        this._downwardItems = true

                        this.search = value

                        // Safe lock release.
                        this.async(() => this._downwardItems = false, 300)
                    }

                    this.debounce(debounceId, debounceFn, debounceTime)
                },

                //// Public APIs. //////////////////////////////////////////////

                reset() {
                    const list = this.$.List

                    list.clearSelection()
                },

                validate() {
                    const menu = this.$.Menu
                    const valid = menu.validate()

                    return valid
                },

                //// Internal APIs. ////////////////////////////////////////////

                // _deselectIsEnabled(deselectable, multi) {
                //     return multi !== true && deselectable === true
                // },

                _itemText(item, path) {
                    return Lodash.get(item, path)
                },

                _doesMatch(item, query) {
                    const fields = this.filterFields
                    const text = fields.reduce((text, field) =>
                         text + (item[field] || '').toLowerCase()
                    , '')
                    const doesMatch = text.includes(query)

                    return doesMatch
                },

                // _restoreSelectedItems(selected) {
                //     if (Lodash.some(arguments, Lodash.isNil) || this.filteredItems.length === 0 || ! this.filter) {
                //         return
                //     }
                //
                //     const list         = this.$.List
                //     const dropdownMenu = this.$.Menu
                //     const menuButton   = dropdownMenu.$$('paper-menu-button')
                //
                //     function selectItem(item) {
                //         const index = Lodash(this.filteredItems).findIndex(item)
                //
                //         if (index < 0) {
                //             return
                //         }
                //
                //         const isMulti = this.$.List.multiSelection
                //
                //         if (isMulti) {
                //             list.selectItem(index)
                //         }
                //         else {
                //             this.configurePaperMenuButton(menuButton, false)
                //             list.selectItem(index)
                //             this.configurePaperMenuButton(menuButton, true)
                //         }
                //     }
                //
                //     const selectedItems = Lodash.flatten([ selected ])
                //
                //     selectedItems.forEach(selectItem, this)
                // },
            })
        })()
        // ]]>
    </script>
</dom-module>
